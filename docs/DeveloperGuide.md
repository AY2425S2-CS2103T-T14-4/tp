---
layout: page
title: Developer Guide
---

* Table of Contents
{:toc}

--------------------------------------------------------------------------------------------------------------------

## **Acknowledgements**

AI Usage

* Existing problems, target direction, and name ideas: Used by Xinkang to brainstorm all of these (Google AI studio)
* User stories: Used by Xinkang to brainstorm target user and come up with user stories. User stories were later edited to fit the required format (Google AI studio)
* Feature Specifications: Used by Xinkang to write initial feature specifications in the required format. Final product was edited to accommodate changes from other group members (O3 mini)
* Code: Used by Dallas for autocompletion and refactoring (GitHub Copilot)
* Javadoc comments: Generated by Marcus to satisfy Checkstyle (ChatGPT, DeepSeek)
* Code and Tests: Used by Xinkang for refactoring, checking, and writing boilerplate(Variety of AI tools)

--------------------------------------------------------------------------------------------------------------------

## **Setting up, getting started**

Refer to the guide [_Setting up and getting started_](SettingUp.md).

--------------------------------------------------------------------------------------------------------------------

## **Design**

<div markdown="span" class="alert alert-primary">

:bulb: **Tip:** The `.puml` files used to create diagrams in this document `docs/diagrams` folder. Refer to the [ _PlantUML Tutorial_ at se-edu/guides](https://se-education.org/guides/tutorials/plantUml.html) to learn how to create and edit diagrams.
</div>

### Architecture

<img src="images/ArchitectureDiagram.png" width="280" />

The ***Architecture Diagram*** given above explains the high-level design of the App.

Given below is a quick overview of main components and how they interact with each other.

**Main components of the architecture**

**`Main`** (consisting of classes [ `Main`](https://github.com/AY2425S2-CS2103T-T14-4/tp/tree/master/src/main/java/seedu/address/Main.java) and [ `MainApp`](https://github.com/AY2425S2-CS2103T-T14-4/tp/tree/master/src/main/java/seedu/address/MainApp.java)) is in charge of the app launch and shutdown.

* At app launch, it initializes the other components in the correct sequence, and connects them up with each other.
* At shutdown, it shuts down the other components and invokes cleanup methods where necessary.

The bulk of the app's work is done by the following four components:

* [**`UI`**](#ui-component): The UI of the App.
* [**`Logic`**](#logic-component): The command executor.
* [**`Model`**](#model-component): Holds the data of the App in memory.
* [**`Storage`**](#storage-component): Reads data from, and writes data to, the hard disk.

[**`Commons`**](#common-classes) represents a collection of classes used by multiple other components.

**How the architecture components interact with each other**

The *Sequence Diagram* below shows how the components interact with each other for the scenario where the user issues the command `delete 1`.

<img src="images/ArchitectureSequenceDiagram.png" width="574" />

Each of the four main components (also shown in the diagram above),

* defines its *API* in an `interface` with the same name as the Component.
* implements its functionality using a concrete `{Component Name}Manager` class (which follows the corresponding API `interface` mentioned in the previous point).

For example, the `Logic` component defines its API in the `Logic.java` interface and implements its functionality using the `LogicManager.java` class which follows the `Logic` interface. Other components interact with a given component through its interface rather than the concrete class (reason: to prevent outside components being coupled to the implementation of a component), as illustrated in the (partial) class diagram below.

<img src="images/ComponentManagers.png" width="300" />

The sections below give more details of each component.

### UI component

The **API** of this component is specified in [ `Ui.java`](https://github.com/AY2425S2-CS2103T-T14-4/tp/tree/master/src/main/java/seedu/address/ui/Ui.java)

![Structure of the UI Component](images/UiClassDiagram.png)

The UI consists of a `MainWindow` that is made up of parts e.g.`CommandBox`, `ResultDisplay`, `PersonListPanel`, `StatusBarFooter` etc. All these, including the `MainWindow`, inherit from the abstract `UiPart` class which captures the commonalities between classes that represent parts of the visible GUI.

The `UI` component uses the JavaFx UI framework. The layout of these UI parts are defined in matching `.fxml` files that are in the `src/main/resources/view` folder. For example, the layout of the [ `MainWindow`](https://github.com/AY2425S2-CS2103T-T14-4/tp/tree/master/src/main/java/seedu/address/ui/MainWindow.java) is specified in [ `MainWindow.fxml`](https://github.com/AY2425S2-CS2103T-T14-4/tp/tree/master/src/main/resources/view/MainWindow.fxml)

The `UI` component,

* executes user commands using the `Logic` component.
* listens for changes to `Model` data so that the UI can be updated with the modified data.
* keeps a reference to the `Logic` component, because the `UI` relies on the `Logic` to execute commands.
* depends on some classes in the `Model` component, as it displays `Person` objects residing in the `Model`.

### Logic component

**API** : [ `Logic.java`](https://github.com/AY2425S2-CS2103T-T14-4/tp/tree/master/src/main/java/seedu/address/logic/Logic.java)

Here's a (partial) class diagram of the `Logic` component:

<img src="images/LogicClassDiagram.png" width="550"/>

The sequence diagram below illustrates the interactions within the `Logic` component, taking `execute("delete 1")` API call as an example.

![Interactions Inside the Logic Component for the `delete 1` Command](images/DeleteSequenceDiagram.png)

<div markdown="span" class="alert alert-info">:information_source: **Note:** The lifeline for `DeleteCommandParser` should end at the destroy marker (X) but due to a limitation of PlantUML, the lifeline continues till the end of diagram. </div>

How the `Logic` component works:

1. When `Logic` is called upon to execute a command, it is passed to an `AddressBookParser` object which in turn creates a parser that matches the command (e.g., `DeleteCommandParser`) and uses it to parse the command.
1. This results in a `Command` object (more precisely, an object of one of its subclasses e.g., `DeleteCommand`) which is executed by the `LogicManager`.
1. The command can communicate with the `Model` when it is executed (e.g. to delete a person).<br> Note that although this is shown as a single step in the diagram above (for simplicity), in the code it can take several interactions (between the command object and the `Model`) to achieve.
1. The result of the command execution is encapsulated as a `CommandResult` object which is returned back from `Logic`.

Here are the other classes in `Logic` (omitted from the class diagram above) that are used for parsing a user command:

<img src="images/ParserClasses.png" width="600"/>

How the parsing works:

* When called upon to parse a user command, the `AddressBookParser` class creates an `XYZCommandParser` (`XYZ` is a placeholder for the specific command name e.g., `AddCommandParser`) which uses the other classes shown above to parse the user command and create a `XYZCommand` object (e.g., `AddCommand`) which the `AddressBookParser` returns back as a `Command` object.
* All `XYZCommandParser` classes (e.g., `AddCommandParser`, `DeleteCommandParser`, ...) inherit from the `Parser` interface so that they can be treated similarly where possible e.g, during testing.

### Model component

**API** : [ `Model.java`](https://github.com/AY2425S2-CS2103T-T14-4/tp/tree/master/src/main/java/seedu/address/model/Model.java)

<img src="images/ModelClassDiagram.png" width="450" />


The `Model` component,

* stores the address book data i.e., all `Person` objects (which are contained in a `UniquePersonList` object).
* stores the currently 'selected' `Person` objects (e.g., results of a search query) as a separate _filtered_ list which is exposed to outsiders as an unmodifiable `ObservableList<Person>` that can be 'observed' e.g. the UI can be bound to this list so that the UI automatically updates when the data in the list change.
* stores a `UserPref` object that represents the userâ€™s preferences. This is exposed to the outside as a `ReadOnlyUserPref` object.
* does not depend on any of the other three components (as the `Model` represents data entities of the domain, they should make sense on their own without depending on other components)

<div markdown="span" class="alert alert-info">:information_source: **Note:** An alternative (arguably, a more OOP) model is given below. It has a `Tag` list in the `AddressBook`, which `Person` references. This allows `AddressBook` to only require one `Tag` object per unique tag, instead of each `Person` needing their own `Tag` objects.<br>

<img src="images/BetterModelClassDiagram.png" width="450" />

</div>

### Storage component

**API** : [ `Storage.java`](https://github.com/AY2425S2-CS2103T-T14-4/tp/tree/master/src/main/java/seedu/address/storage/Storage.java)

<img src="images/StorageClassDiagram.png" width="550" />

The `Storage` component,

* can save both address book data and user preference data in JSON format, and read them back into corresponding objects.
* inherits from both `AddressBookStorage` and `UserPrefStorage`, which means it can be treated as either one (if only the functionality of only one is needed).
* depends on some classes in the `Model` component (because the `Storage` component's job is to save/retrieve objects that belong to the `Model`)

### Common classes

Classes used by multiple components are in the `seedu.address.commons` package.

--------------------------------------------------------------------------------------------------------------------

## **Implementation**

This section describes some noteworthy details on how certain features are implemented.

### Filtering the persons list

#### Implementation

The filtering mechanism is facilitated by the `Model` interface with the following operations:

* `Model#updateFilteredPersonList(Predicate<Person>)`â€” Filters which `Person` are displayed to the user. This method uses Java's `Predicate` interface, for which there are multiple implementing classes.
* `Model#getFilteredPersonList()`â€” Returns the current list of filtered `Person`.

<img src="images/FilteringDiagram.png" width="450" />

The filtering mechanism works as follows:

Step 1. When a filtering command is executed, the command's parser creates an appropriate `Predicate` based on the user input and passes it to the command.

Step 2. The command then calls `model.updateFilteredPersonList(predicate)` to apply the filter.

Step 3. The UI automatically updates to display only the filtered persons.

#### Design considerations:

**Aspect: How to implement complex filtering:**

* **Alternative 1 (current choice):** Composite predicates are used that combine simpler predicates.
    * Pros: More maintainable as there is less repeated code.
    * Cons: May be more complex to implement initially.

* **Alternative 2:** Independent predicates.
    * Pros: Easier to implement as filtering the logic can be directly used.
    * Cons: It is less maintainable as the same logic may be re-implemented multiple times.

### \[Proposed\] Undo/redo feature

#### Proposed Implementation

The proposed undo/redo mechanism is facilitated by `VersionedAddressBook`. It extends `AddressBook` with an undo/redo history, stored internally as an `addressBookStateList` and `currentStatePointer`. Additionally, it implements the following operations:

* `VersionedAddressBook#commit()`â€” Saves the current address book state in its history.
* `VersionedAddressBook#undo()`â€” Restores the previous address book state from its history.
* `VersionedAddressBook#redo()`â€” Restores a previously undone address book state from its history.

These operations are exposed in the `Model` interface as `Model#commitAddressBook()`, `Model#undoAddressBook()` and `Model#redoAddressBook()` respectively.

Given below is an example usage scenario and how the undo/redo mechanism behaves at each step.

Step 1. The user launches the application for the first time. The `VersionedAddressBook` will be initialized with the initial address book state, and the `currentStatePointer` pointing to that single address book state.

![UndoRedoState0](images/UndoRedoState0.png)

Step 2. The user executes `delete 5` command to delete the 5th person in the address book. The `delete` command calls `Model#commitAddressBook()`, causing the modified state of the address book after the `delete 5` command executes to be saved in the `addressBookStateList`, and the `currentStatePointer` is shifted to the newly inserted address book state.

![UndoRedoState1](images/UndoRedoState1.png)

Step 3. The user executes `add n/David â€¦â€‹` to add a new person. The `add` command also calls `Model#commitAddressBook()`, causing another modified address book state to be saved into the `addressBookStateList`.

![UndoRedoState2](images/UndoRedoState2.png)

<div markdown="span" class="alert alert-info">:information_source: **Note:** If a command fails its execution, it will not call `Model#commitAddressBook()`, so the address book state will not be saved into the `addressBookStateList`.

</div>

Step 4. The user now decides that adding the person was a mistake, and decides to undo that action by executing the `undo` command. The `undo` command will call `Model#undoAddressBook()`, which will shift the `currentStatePointer` once to the left, pointing it to the previous address book state, and restores the address book to that state.

![UndoRedoState3](images/UndoRedoState3.png)

<div markdown="span" class="alert alert-info">:information_source: **Note:** If the `currentStatePointer` is at index 0, pointing to the initial AddressBook state, then there are no previous AddressBook states to restore. The `undo` command uses `Model#canUndoAddressBook()` to check if this is the case. If so, it will return an error to the user rather than attempting to perform the undo.

</div>

The following sequence diagram shows how an undo operation goes through the `Logic` component:

![UndoSequenceDiagram](images/UndoSequenceDiagram-Logic.png)

<div markdown="span" class="alert alert-info">:information_source: **Note:** The lifeline for `UndoCommand` should end at the destroy marker (X) but due to a limitation of PlantUML, the lifeline reaches the end of diagram.

</div>

Similarly, how an undo operation goes through the `Model` component is shown below:

![UndoSequenceDiagram](images/UndoSequenceDiagram-Model.png)

The `redo` command does the opposite â€” it calls `Model#redoAddressBook()`, which shifts the `currentStatePointer` once to the right, pointing to the previously undone state, and restores the address book to that state.

<div markdown="span" class="alert alert-info">:information_source: **Note:** If the `currentStatePointer` is at index `addressBookStateList.size() - 1`, pointing to the latest address book state, then there are no undone AddressBook states to restore. The `redo` command uses `Model#canRedoAddressBook()` to check if this is the case. If so, it will return an error to the user rather than attempting to perform the redo.

</div>

Step 5. The user then decides to execute the command `list`. Commands that do not modify the address book, such as `list`, will usually not call `Model#commitAddressBook()`, `Model#undoAddressBook()` or `Model#redoAddressBook()`. Thus, the `addressBookStateList` remains unchanged.

![UndoRedoState4](images/UndoRedoState4.png)

Step 6. The user executes `clear`, which calls `Model#commitAddressBook()`. Since the `currentStatePointer` is not pointing at the end of the `addressBookStateList`, all address book states after the `currentStatePointer` will be purged. Reason: It no longer makes sense to redo the `add n/David â€¦â€‹` command. This is the behavior that most modern desktop applications follow.

![UndoRedoState5](images/UndoRedoState5.png)

The following activity diagram summarizes what happens when a user executes a new command:

<img src="images/CommitActivityDiagram.png" width="250" />

#### Design considerations:

**Aspect: How undo & redo executes:**

* **Alternative 1 (current choice):** Saves the entire address book.
    * Pros: Easy to implement.
    * Cons: May have performance issues in terms of memory usage.

* **Alternative 2:** Individual command knows how to undo/redo by
  itself.
    * Pros: Will use less memory (e.g. for `delete`, just save the person being deleted).
    * Cons: We must ensure that the implementation of each individual command is correct.

--------------------------------------------------------------------------------------------------------------------

## **Documentation, logging, testing, configuration, dev-ops**

* [Documentation guide](Documentation.md)
* [Testing guide](Testing.md)
* [Logging guide](Logging.md)
* [Configuration guide](Configuration.md)
* [DevOps guide](DevOps.md)

--------------------------------------------------------------------------------------------------------------------

## **Appendix: Requirements**

### Product scope

**Target user profile**:

* Network marketeer
* Has a need to manage a significant number of persons
* Each person has a commission to track
* Prefer desktop apps over other types
* Can type fast
* Prefers typing to mouse interactions
* Is reasonably comfortable using CLI apps

**Value proposition**: Manage persons faster than a typical mouse/GUI driven app and easily track commission of persons.

### User stories

Priorities: High (must have) - `* * *`, Medium (nice to have) - `* *`, Low (unlikely to have) - `*`

| Priority | As a â€¦                           | I want to â€¦                                         | So that I canâ€¦                                                         |
|:--------:|----------------------------------|-----------------------------------------------------|------------------------------------------------------------------------|
| `* * *`  | New user                         | See usage instructions                              | Refer to instructions when I forget how to use the App                 |
| `* * *`  | User                             | Add a new person                                    |                                                                        |
| `* * *`  | User                             | Edit a person                                       | Change the information reflected when their information changes        |
| `* * *`  | User                             | Delete a person                                     | Remove entries that I no longer need                                   |
| `* * *`  | User                             | Find a person by name                               | Locate details of persons without having to go through the entire list |
| `* * *`  | User                             | Show all persons                                    | Manage them together                                                   |
| `* * *`  | User                             | Close the app                                       |                                                                        |
|  `* *`   | User                             | Clear my persons                                    | Start from a fresh state                                               |
|  `* *`   | User                             | Add existing persons to currently displayed persons | Quickly create a custom view of persons                                |
| `* * *`  | Marketeer with a segmented lists | Find a person by tags                               | Quickly access specific groups of persons                              |
| `* * *`  | Data enthusiast                  | Export reports                                      | Further analyze with external systems                                  |
| `* * *`  | Team leader                      | Record the commission earned from team members      | Monitor the financial impact of my team expansion                      |
|  `* *`   | Time-conscious communicator      | Send bulk messages to specific groups of persons    | Share updates quickly without crafting individual messages             |
|  `* *`   | Well connected person            | Sort persons by attributes                          | Locate a person easily                                                 |
|  `* *`   | Efficient user                   | Tag multiple persons at once                        | Quickly organize large groups of persons                               |
|  `* *`   | Efficient user                   | Remove tags from multiple persons at once           | Clear out unused tags from all my persons                              |
|   `*`    | Team leader                      | Visualize my network of downlines                   | Monitor the progress of my team expansion                              |

### Use cases

(For all use cases below, the **System** is the `AscendNetwork` and the **Actor** is the `user`, unless specified otherwise)

**Use case: UC1 - Show all persons**

**MSS**

1. User requests to list persons
2. AddressBook shows the list of all persons.
   Use case ends.

**Extensions**

* 2a. The list is empty.
  Use case ends.

**Use case: UC2 - Add a person**

**MSS**

1. User requests to add a person
2. AscendNetwork adds the person

   Use case ends.

**Extensions**

* 1a. The user uses invalid format.

    * 1a1. AscendNetwork shows an error message.

      Use case resumes at step 1.
* 1b. The user tries to add a person that is already in the contact.
    * 1b1. AscendNetwork shows an error message.

      Use case resumes at step 1.

**Use case: UC3 - Edit a person**

1.  User <ins>shows all contacts (UC1)</ins>.
2.  User requests to edit a specific person in the list.
3.  User states which fields to update and provides updated details.
4.  AscendNetwork edits the person with updated details.
    Use case ends.

**Extensions**

* 2a. The given index is invalid.
    * 2a1. AscendNetwork shows an error message.
      Use case resumes at step 1.
* 3a. The details provided are invalid.
    * 3a1. AscendNetwork shows an error message.
      Use case resumes at step 1.

**Use case: UC4 - Delete a person**

**MSS**

1.  User <ins>shows all persons (UC1)</ins>.
2.  User requests to delete a specific person in the list.
3.  AscendNetwork deletes the person.
    Use case ends.

**Extensions**

* 2a. The given index is invalid.
    * 2a1. AscendNetwork shows an error message.
      Use case resumes at step 1.

**Use case: UC5 - Find persons by name and tag**

**MSS**

1.  User <ins>shows all persons (UC1)</ins>.
2.  User requests to find persons with names and tags.
3.  AscendNetwork shows all persons that pass the filter.
    Use case ends.

**Extensions**

* 2a. The user does not provide any filter criteria.
    * 2a1. AscendNetwork shows an error message.
      Use case resumes at step 1.
* 2b. The user provides filter in an incorrect format.
    * 2b1. AscendNetwork shows an error message.
      Use case resumes at step 1.
* 3a. No persons pass the filter. No persons are shown.
  Use case ends.

**Use case: UC6 - Add commission received from person**

**MSS**

1.  User <ins>shows all persons (UC1)</ins>.
2.  User requests to add commission received from a specific downline in the list and specifies the amount of commission received.
4.  AscendNetwork records the commission received from that person.
    Use case ends.

**Extensions**

* 2a. The given index is invalid.
    * 2a1. AscendNetwork shows an error message.
      Use case resumes at step 1.
* 3a. User provides invalid input for the commission amount (e.g., non-numeric).
    * 3b1. AscendNetwork shows an error message indicating invalid commission amount.
      Use case resumes at step 3.

**Use case: UC7 - Tag multiple persons at once**

**MSS**

1. User <ins>finds persons by name and tag (UC5)</ins>.
2. User requests to tag all persons currently shown.
3. AscendNetwork adds the tags to all persons currently shown.
   Use case ends.

**Extensions**

* 2a. The user does not provide any tags to add.
    * 2a1. AscendNetwork shows an error message.
      Use case resumes at step 1.
* 2b. The user provides tags with invalid format.
    * 2b1. AscendNetwork shows an error message.
      Use case resumes at step 1.
* 2c. No persons are currently shown.
    * 2c1. AscendNetwork shows an error message.
      Use case resumes at step 1.

**Use case: UC8 - Mail to multiple persons**

**MSS**

1. User <ins>find persons by name and tag (UC5)</ins>.
2. User requests to generate a `mailto` link for all persons currently on the list.
3. AscendNetwork generates and displays the requested link.
4. User copies the link to their browser's address bar to open the system mail client.
   Use case ends.

**Extensions**

* 2a. The list is empty.
    * 2a1. AscendNetwork shows an error message.
      Use case resumes at step 1.

**Use case: UC9 - Sorting displayed List**

**MSS**

1.  User <ins>shows all persons (UC1)</ins>.
2.  User issues a command to sort the displayed list.
3.  AscendNetwork sorts the displayed list based on the specified criteria.
4.  AscendNetwork displays the sorted list of persons.
    Use case ends.

**Extensions**

* 2a. User provides an invalid sort command format or missing sort criteria.
    * 2a1. AscendNetwork shows an error message indicating the invalid command format or missing criteria.
      Use case resumes at step 1.
* 2b. User provides an unsupported sort criteria.
    * 2b1. AscendNetwork shows an error message indicating that the specified criteria is not supported for sorting.
      Use case resumes at step 1.

**Use case: UC10 - Export multiple matching persons**

**MSS**

1.  User <ins>finds persons by name and tag (UC5)</ins>.
2.  User requests to export the details of the currently displayed persons.
3.  User provides the file name to export the file to.
4.  User selects which fields to export from the currently displayed persons.
5.  AscendNetwork exports persons to the specified file name.
    Use case ends.

**Extensions**   

* 2a. The list is empty.
    * 2a1. AscendNetwork shows an error message.
      Use case resumes at step 1.
* 3a. The file name is not valid.
    * 2a1. AscendNetwork shows an error message.
      Use case resumes at step 1.
* 4a. The user selects invalid fields.
    * 3a1. AscendNetwork shows an error message.
      Use case resumes at step 1.

**Use case: UC11 - Remove Tag from multiple persons at once**

**MSS**

1. User <ins>finds persons by name and tag (UC5)</ins>.
2. User requests to remove some tags from all persons shown.
3. AscendNetwork removes the tags from all persons shown.
   Use case ends.

**Extensions**

* 2a. The user does not provide any tags to remove.
    * 2a1. AscendNetwork shows an error message.
      Use case resumes at step 1.
* 2b. The user provides tags with invalid format.
    * 2b1. AscendNetwork shows an error message.
      Use case resumes at step 1.
* 2c. No persons are currently shown.
    * 2c1. AscendNetwork shows an error message.
      Use case resumes at step 1.

**Use case: UC12 - Add existing persons to the list**

**MSS**

1. User requests to add persons by their names to the list.
2. AscendNetwork adds those persons that pass the filter to the list.

Use case ends.

**Extensions**
* 1a. The user does not provide any name keyword.
    * 1a1. AscendNetwork shows an error message.
      Use case resumes at step 1.
* 1b. The user provides keywords that don't exist in the address book.
    * 1b1. AscendNetwork shows that 0 persons are added.
      Use case resumes at step 1.

**Use case: UC13 - Summarize information about current list of persons**

**MSS**

1. User requests to see summary information about persons.
2. AscendNetwork displays summary information about persons.

Use case ends.

**Use case: UC14 - See the persons with the highest or lowest commissions**

**MSS**

1. User requests to see the persons with the highest or lowest commissions.
2. AscendNetwork displays the persons with the highest or lowest commissions.

Use case ends.

**Extensions**
* 1a. The user does not provide any sort direction.
    * 1a1. AscendNetwork shows an error message.
      Use case resumes at step 1.
* 1b. The user provides an invalid sort direction.
    * 1b1. AscendNetwork shows an error message.
      Use case resumes at step 1.

**Use case: UC15 - Clear all persons**

**MSS**

1. User requests to clear all persons.
2. AscendNetwork clears all persons from its data.
   Use case ends.

**Use case: UC16 - Display help window**

**MSS**

1. User requests for help on how to use AscendNetwork.
2. AscendNetwork displays a window with a link to the user guide.

Use case ends.

**Extensions**
* 1a. The help window is already open.
    * 1a1. AscendNetwork refocuses the window.
      Use case ends.

### Non-Functional Requirements

1. Should work on any _mainstream OS_ as long as it has Java `17` or above installed.
2. Should be able to hold up to 1000 persons without a noticeable sluggishness in performance for typical usage.
3. A user with above-average typing speed for regular English text (i.e., not code, not system admin commands) should be able to accomplish most tasks faster using commands than using the mouse.
4. The application should be fully portable and should not require installation. Users should be able to run the application by executing a single JAR file.
5. The software should be developed incrementally, ensuring a stable, working product at every stage of development.
6. The application should be optimized for a screen resolution of at least `1920x1080`, ensuring usability at resolutions as low as `1280x720`. It should also support scaling factors of `100%`, `125%` and remain functional at `150%`.
7. Data should be stored in a human-editable text file, allowing advanced users to modify it manually if needed.
8. The product should not require an internet connection for core functionality, ensuring usability in offline environments.
9. The software should follow an object-oriented design, using OOP principles to manage data and features effectively.
10. No third-party database management system (DBMS) should be used to store data.
11. The application should not depend on a remote server for its functionality, ensuring that it remains accessible even after project completion.
12. The software package, including all dependencies, should not exceed `100MB`, and documentation files should not exceed `15MB` per file.
13. The software should ensure a smooth user experience across Windows, macOS, and Linux by avoiding OS-dependent libraries and system-specific functionalities.
14. The primary mode of interaction should be through a command-line interface (CLI), with the GUI primarily used for visual feedback. A CLI input should be faster than its GUI alternative whenever applicable.
15. The software should be testable, avoiding features that introduce unnecessary complexity in manual or automated testing, such as account-based authentication, audio-based interactions, or extensive reliance on external APIs.
16. The final product should be delivered in a single JAR file. If this is not possible, all required files should be packaged into a single ZIP archive.

### Glossary

* **Mainstream OS**: Windows, Linux, Unix, MacOS
* **Person/Contact**: An entry in the AscendNetwork
* **Downline**: A person that is lower in the marketing network than the user
* **Commission**: The amount of money received from the person through sales

--------------------------------------------------------------------------------------------------------------------

## **Appendix: Instructions for manual testing**

Given below are instructions to test the app manually.

<div markdown="span" class="alert alert-info">:information_source: **Note:** These instructions only provide a starting point for testers to work on;
testers are expected to do more *exploratory* testing.

</div>

### Launch and shutdown

1. Initial launch

    1. Download the jar file and copy it into an empty folder.

    1. Double-click the jar file. Expected: Shows the GUI with a set of sample persons. The window size may not be optimum.

1. Saving window preferences

    1. Resize the window to an optimum size. Move the window to a different location. Close the window.

    1. Re-launch the app by double-clicking the jar file.<br>
       Expected: The most recent window size and location is retained.

### Deleting a person

1. Deleting a person while all persons are being shown

    1. Prerequisites: List all persons using the `list` command. Multiple persons in the list.

    1. Test case: `delete 1`<br>
       Expected: First person is deleted from the list. Details of the deleted person shown in the status message. Timestamp in the status bar is updated.

    1. Test case: `delete 0`<br>
       Expected: No person is deleted. Error details shown in the status message. Status bar remains the same.

    1. Other incorrect delete commands to try: `delete`, `delete x`, `...` (where x is larger than the list size)<br>
       Expected: Similar to previous.

### Summary Command
1. Summarize the statistics while all persons are being shown
    1. Prerequisites: Ensure there are multiple persons on the list

    2. Test case: `summary`<br>
        Expected: Statistics for the list that is currently displayed are displayed, including the number of contacts, total commission, highest commission, lowest commission, and the average commission

    3. Test case: `find n/NAME` where NAME is the name of a unique person in the list, then `summary`<br>
        Expected: Statistics for the one person that is currently displayed are displayed, including the number of contacts, total commission, highest commission, lowest commission, and the average commission

1. Summarizing statistics when list is empty
   1. Prerequisites: List is empty
   
   2. `summary`<br>
      "List is empty, nothing to do" error message should be displayed

### Commission View Command
1. Displays the commissions within the current list
    1. Prerequisites: Ensure there are multiple persons with different commissions on the list

    2. Test case: `comm s/asc`<br>
       Expected: PERSON, $COMMISSION displayed where COMMISSION is listed in ascending order

    3. Test case: `comm s/desc`<br>
       Expected: PERSON, $COMMISSION displayed where COMMISSION is listed in descending order

       4. Test case: `comm`<br>
       Expected: "Invalid command format! comm s/<direction> where <direction> is either asc or desc. Example: comm s/asc" error message is printed

1. Sorting by commission when list is empty
   1. Test case: `comm s/asc`<br>
        Expected: "List is empty, nothing to do" error message should be displayed

### Find multiple person

1. Find multiple persons to only show a subset

    1. Test case: `find n/NAME t/TAG` (where `NAME` and `TAG` matches at least one word in the name and tag respectively of at least one same person)<br>
       Expected: Only the persons who match are displayed. The number of matched persons is shown in the status message.

    1. Test case: `find n/ t/`<br>
       Expected: No filtering is done. Error details shown in the status message.

### Tag multiple person

1. Tagging all listed persons

    1. Prerequisites: At least one person is displayed on the list.

    1. Test case: `tag customer`<br>
       Expected: All persons currently listed are tagged with `customer`. The number of people with the tag added is shown in the status message.

    1. Test case: `tag`<br>
       Expected: No person is tagged. Error details shown in the status message.

### Removing tags

1. Removing tag from all listed persons

    1. Prerequisites: At least one person is displayed on the list.

    1. Test case: `rmtag customer`<br>
       Expected: All persons currently listed have the `customer` tag removed from them. The number of people with the tag removed is shown in the status message.

    1. Test case: `rmtag`<br>
       Expected: No person has tags removed. Error details shown in the status message.

### Exporting contacts to CSV

1. Exporting all visible contacts with full details

    1. Prerequisites: List all persons using the `list` command. Multiple persons in the list.

    1. Test case: `export data.csv`<br>
       Expected: A file named `data.csv` is created in AscendNetwork's current directory. All contact details (name, phone, email, address, commission) from the visible list are exported. A success message is shown in the status message.

    1. Test case: `export data.csv` (when `data.csv` already exists)<br>
       Expected: Export fails. Error message shown in the status message indicating the file already exists.

    1. Test case: `export DATA.csv` (when `data.csv` already exists in a system that is case-aware but case-insensitive e.g. Windows)<br>
       Expected: Export fails. Error message shown in the status message indicating the file already exists.

2. Exporting filtered contacts with selected attributes

    1. Prerequisites: Use `find` to filter the contacts, e.g., `find n/Alice`. Ensure at least one contact matches.

    1. Test case: `export filtered.csv a/name a/email`<br>
       Expected: A file named `filtered.csv` is created, containing only the names and emails of visible contacts. A success message is shown.

    1. Test case: `export data.csv a/phone a/PHONE`<br>
       Expected: Export fails, since there are duplicate attributes requested (`phone` and `PHONE` are considered the same), with relevant error message.

    1. Test case: `export data.csv a/`<br>
       Expected: Export fails, since there are invalid attributes requested, with relevant error message.

3. Exporting when there are no visible contacts.

    1. Prerequisites: Use `find` to filter the contacts, e.g., `find n/Alice`. Ensure no contact matches.

    1. Test case: `export data.csv`<br>
       Expected: Export fails, since there are no visible contacts to export.

### Generating mailto link

1. Generating a mailto link from all visible contacts

    1. Prerequisites: List all persons using the `list` command. Multiple persons in the list. Ensure contacts have valid email addresses.

    1. Test case: `mailto`<br>
       Expected: A mailto link is generated with emails of all visible contacts. A pop-up window is opened with a 'Copy URL' button. When clicked, the button overwrites the system clipboard with the generated mailto link. AscendNetwork displays success message.

2. Generating a mailto link when no persons are visible

    1. Prerequisites: List all persons using the `list` command. No persons in the list.

    1. Test case: `mailto`<br>
       Expected: No mailto link is generated. Pop-up window is not opened. AscendNetwork displays error message indicating there are no contacts to include.

3. Generating a mailto link after `help` command has been used

    1. Prerequisites: `help` command is executed and the window is left open.

    1. Test case: `mailto`<br>
       Expected: Contents of the window is replaced with those related to `mailto`.

### Adding a commission

1. Adding commission to the specified indexed person.
    1. Prerequisites: Multiple persons in the list.
    2. Test case: `addc 1 c/12` <br>
       Expected: 12 commission is added to the first person.
    3. Test case: `addc 1 c/1000000000` <br>
       Expected: Invalid commission. Error details shown in the status message.

### Including a persons

1. Including specific persons to the list
    1. Test case: `incl n/NAME` <br>
       Expected: Persons matched added to the list. The number of persons added to list is shown in the status message.
    2. Test case: `incl 1 n/` <br>
       Expected: No person is added. Error details shown in the status message.

--------------------------------------------------------------------------------------------------------------------

## **Appendix: Planned enhancements**

Team size: 4

1. **Allow finding by other attributes**: The current find command is able to find persons by both name and tags. We plan to extend its capabilities to cover all attributes of a person in ways that are meaningful for it e.g. the commission attribute can be filtered by a range using an upper and lower limit. This would allow users to better organize their contacts and use commands that operate on the displayed list

1. **Allow including by other attributes**: The current incl command only use name to include persons to the currently displayed list. We plan to extend its capabilities to cover all attributes of a person. e.g. the persons can be included by their common addresses. This would allow users to better organize their contacts and use commands that operate on the displayed list

1. **Enable copying contact details**: The current UI does not allow text in the person list to be copied onto users' clipboards. We plan to create this capability so that users can copy over existing contact details into other software, rather than manually typing them out.

1. **Support non-alphanumeric inputs in all fields**: AscendNetwork currently doesn't allow certain names (e.g. s/o, d/o in Indian, Ah-Beng in Chinese), emails, and addresses for ease of implementation. We plan to relax our input validation to support more valid legal names, emails and addresses.

1. **Indicate conflicting file name in export**: Currently AscendNetwork will fail to `export` if a similarly-named file is already present. The app does not indicate which is the conflicting file name (e.g. `data.csv` vs `DATA.csv`). We plan to improve this along with other error reporting.

1. **Allow comm command to modify list of persons**: Currently AscendNetwork prints out the list of persons when comm is run, we plan to enable the command to modify the actual list of persons.

## **Appendix: Effort**
This project required significant effort and collaboration across the team to achieve the goals we set out. Below, we summarize the key aspects of the projectâ€™s difficulty, challenges, time investment, and achievements.

### Difficulty Level and Scope
Compared to AB3, which manages only a single attribute (e.g. Name), our project introduces and modifies several commands to handle multiple attributes, each with distinct behaviors, like Email and Phone, of multiple Persons. This added significant design and implementation complexity. For instance, commands such as find, tag, comm, and export had to be adapted to operate across different attributes, each with its own filtering and sorting criteria. This means that we have to make careful architectural decisions to avoid code duplication while maintaining command clarity and correctness across all supported attributes. A notable addition is the Commission attribute , which introduced its own set of challenges. We built extensive functionalities around commissions, including:
- Sorting commissions.
- Summing total commissions across a filtered list.
- Implementing overflow-safe arithmetic operations, ensuring financial calculations remain accurate even when dealing with large datasets or values.

Other features include:
- Expansion of Functionality: We doubled the number of supported commands, which required not only implementing new logic but also ensuring consistency, test coverage, and appropriate error handling.
- Filtering and Sorting: We introduced an extensive and flexible filtering and sorting feature, enabling users to query and organize data with high specificity. This required designing and implementing a modular filter system that could compose multiple conditions and work across entity types.
- Export function: There are challenges related to format compatibility, error resilience, and testing.
- Documentation: We produced extensive documentation, covering user guides, developer guides, and architectural decisions. This required significant effort to ensure clarity, accuracy, and accessibility for both technical and non-technical audiences.

### Effort Required
The project effort was spread across design (20%), implementation (50%), testing (15%), and documentation (15%). The team also conducted multiple rounds of code reviews, user testing, and bug fixes to ensure quality. We did not rely on external libraries for any part of the project. All functionality, including filtering, summarizing and external system interaction, was developed in-house. This means 100% of the effort represents original work, with no time saved through external reuse.

### Achievements
- Code coverage improved from 75% to 80%, despite the larger codebase.
- Number of commands supported was doubled.
- Filtering and sorting features are now significantly more powerful and flexible.
- External systems can now leverage our application data (through csv), broadening its real-world applicability.
- We delivered extensive documentation, greatly improving the maintainability and usability of the system.
